# ============================================================
# Strapi CI (GitOps loop)
# - Build Strapi
# - Build & push immutable image (tag = full commit SHA) to GHCR
# - Trivy scan (HIGH/CRITICAL, non-blocking for demo)
# - Create a PR that bumps GitOps values for BOTH prod + dev:
#     - gitops/apps/strapi/chart/values-prod.yaml
#     - gitops/apps/strapi/chart/values-dev.yaml
# Merge PR -> ArgoCD auto-sync -> Kubernetes rollout
# ============================================================

name: Strapi CI (build -> push -> PR bump GitOps prod+dev)

on:
  # Run on every push to main, but only if Strapi or this workflow changed
  push:
    branches: ["main"]
    paths:
      - "strapi/**"
      - ".github/workflows/strapi-ci.yml"

  # Allow manual run from GitHub UI (Actions tab)
  workflow_dispatch: {}

# These permissions are required because the workflow:
# - pushes Docker images to GHCR (packages: write)
# - creates commits/branches and opens PRs (contents: write, pull-requests: write)
permissions:
  contents: write
  pull-requests: write
  packages: write

# Prevent multiple runs fighting each other (e.g., pushing twice quickly).
# If a newer run starts, the older one is cancelled.
concurrency:
  group: strapi-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build_scan_push_and_pr:
    runs-on: ubuntu-latest

    # IMPORTANT:
    # We do NOT want the workflow to re-run because of the bot PR commit.
    # Otherwise you get a loop: workflow bumps GitOps -> PR commit triggers workflow -> ...
    if: github.actor != 'github-actions[bot]'

    # Shared variables used across steps
    env:
      # Target image registry/repo (GHCR)
      IMAGE: ghcr.io/${{ github.repository_owner }}/strapi

      # GitOps files to bump (your repo structure)
      # NOTE: You said you have values-prod.yaml and values-dev.yaml here:
      PROD_FILE: gitops/apps/strapi/chart/values-prod.yaml
      DEV_FILE:  gitops/apps/strapi/chart/values-dev.yaml

    steps:
      # -------------------------
      # 1) Checkout repository
      # -------------------------
      - name: Checkout
        uses: actions/checkout@v4

      # -------------------------
      # 2) Node setup + build (fast failure before Docker build)
      # This proves: dependencies install + admin UI builds cleanly.
      # -------------------------
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps (strapi/)
        working-directory: strapi
        run: npm ci

      # Simple lint test TypeScript typecheck step

      - name: Typecheck (tsc)
        working-directory: strapi
        run: npm run typecheck


      - name: Build Strapi admin (strapi/)
        working-directory: strapi
        run: npm run build

      # -------------------------
      # 3) Docker setup + login
      # -------------------------
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # -------------------------
      # 4) Compute immutable tag = FULL commit SHA
      # This is ideal GitOps: every deployment points to an exact immutable artifact.
      # -------------------------
      - name: Compute tag (full commit SHA)
        id: tag
        run: echo "t=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      # -------------------------
      # 5) Build & push image (only SHA tag, no :latest)
      # This keeps deployments deterministic and avoids "latest drift".
      # -------------------------
      - name: Build and push image (immutable SHA tag)
        uses: docker/build-push-action@v6
        with:
          context: ./strapi
          file: ./strapi/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE }}:${{ steps.tag.outputs.t }}

      # -------------------------
      # 6) Security scan (Trivy)
      # For exam demo we keep it NON-BLOCKING (exit-code: 0),
      # but still show HIGH/CRITICAL results in logs.
      # -------------------------
      - name: Trivy scan (HIGH/CRITICAL, non-blocking)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE }}:${{ steps.tag.outputs.t }}
          format: table
          severity: HIGH,CRITICAL
          ignore-unfixed: false
          exit-code: "1"

      # -------------------------
      # 7) GitOps bump (prod + dev)
      # This edits BOTH values files and updates:
      #   image:
      #     tag: "<sha>"
      #
      # NOTE:
      # We pass FILE and SHA correctly into Python:
      #   FILE="$FILE" SHA="$SHA" python3 ...
      # This avoids your previous KeyError: 'FILE'.
      # -------------------------
      - name: Bump GitOps values (prod + dev) to new SHA tag
        shell: bash
        run: |
          set -euo pipefail

          SHA="${{ steps.tag.outputs.t }}"
          echo "New image tag: $SHA"

          bump_file () {
            local FILE="$1"

            # Hard fail if file is missing (keeps the workflow honest)
            if [ ! -f "$FILE" ]; then
              echo "âŒ Missing file: $FILE"
              exit 1
            fi

            echo "Updating $FILE -> image.tag: $SHA"

            # IMPORTANT:
            # Export vars for this python process only (FILE + SHA)
            FILE="$FILE" SHA="$SHA" python3 - <<'PY'
          import os

          path = os.environ["FILE"]
          sha  = os.environ["SHA"]

          lines = open(path, "r", encoding="utf-8").read().splitlines(True)

          out = []
          in_image = False
          image_indent = None
          replaced = False

          for line in lines:
              # Enter image: block
              if not in_image and line.lstrip().startswith("image:"):
                  in_image = True
                  image_indent = len(line) - len(line.lstrip())
                  out.append(line)
                  continue

              # Exit image block when we reach next top-level key
              if in_image:
                  cur_indent = len(line) - len(line.lstrip())
                  if line.strip() and cur_indent <= image_indent and not line.lstrip().startswith(("#", "-")):
                      in_image = False

              # Replace tag inside image block
              if in_image and line.lstrip().startswith("tag:"):
                  indent = line[:len(line) - len(line.lstrip())]
                  out.append(f'{indent}tag: "{sha}"\n')
                  replaced = True
              else:
                  out.append(line)

          if not replaced:
              raise SystemExit(f"Did not find image.tag to replace in {path}")

          open(path, "w", encoding="utf-8").write("".join(out))
          PY
          }

          bump_file "${PROD_FILE}"
          bump_file "${DEV_FILE}"

      # -------------------------
      # 8) Create PR for GitOps bump
      # We explicitly limit PR content via add-paths to ONLY the two values files.
      # That keeps PR clean and avoids accidentally committing anything else.
      #
      # NOTE:
      # For this to work, repo settings must allow:
      # - Workflow permissions: Read and write
      # - Allow GitHub Actions to create and approve pull requests
      # -------------------------
      - name: Create PR for GitOps bump
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

          # Unique branch name per commit SHA
          branch: ci/strapi-bump-${{ steps.tag.outputs.t }}

          # Auto-delete after merge to keep repo clean
          delete-branch: true
          base: main

          # Commit + PR metadata
          commit-message: "chore(strapi): bump image tag to ${{ steps.tag.outputs.t }}"
          title: "chore(strapi): bump image tag to ${{ steps.tag.outputs.t }}"
          body: |
            This PR updates Strapi GitOps source-of-truth to the new immutable image tag.

            - Image: `${{ env.IMAGE }}:${{ steps.tag.outputs.t }}`
            - Files:
              - `gitops/apps/strapi/chart/values-prod.yaml`
              - `gitops/apps/strapi/chart/values-dev.yaml`

            Merge -> ArgoCD auto-sync -> rollout.

          # SUPER IMPORTANT: only include these files in the PR commit
          add-paths: |
            gitops/apps/strapi/chart/values-prod.yaml
            gitops/apps/strapi/chart/values-dev.yaml
